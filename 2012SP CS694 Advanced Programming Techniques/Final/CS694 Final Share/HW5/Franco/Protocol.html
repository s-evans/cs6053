<html>
<head>
<title>I-Wars C694 Project Protocol</title>
<meta name="ROBOTS" content="index,follow">
<meta name="keywords" content=" $keywords-body$">
<meta name="DESCRIPTION" content="Project Protocol">
<meta name="Edited" content="Fri, 15 May 2009 14:18:31 GMT">
<meta name="Published" content="Fri, 15 May 2009 14:21:26 GMT">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" href="mainStyle.css" type="text/css" media="screen">
</head>
<body bgcolor="#FFFFDF">
<center>
<table cellspacing=10>

<tr>
<th width=200><b><font color="#0000bb">20-CS-694</font></b></th>
<th width=500><b><font color="#bb0000" size=+1>Advanced Programming Techniques</font></b></th>
<th width=200><b><font color="#0000bb">Spring 2012</font></b></th>
</tr>


<tr>
<th></th>
<th><font color="#0000bb" size=+1><b>I-Wars Project</b></font></th>
<th></th>
</tr>

</table>

<hr width=50% color=#bb00bb>
<font color="#FF0000" size=-2>
<nobr>Interfaces, Exceptions, Graphics, Animation, Threads, Reflection, Networking, RMI, JDBC, JNI</nobr><br>
</font>
<hr width=50% color=#bb00bb>
<p> <!--&nbsp;<br>-->



<font size=+2 color="#0000FF"><b>I-Wars Protocol Specification, Version 2.9</b></font>
<p>
</center>
<p>

<div style="margin:0em 3em;">
<table width=90%>

<tr>
<td colspan=4>
<font size=+1 color="#0000BB"><b>Other Resources:</b></font></td>
</tr>

<tr>
<td>&nbsp;&nbsp;&nbsp;</td>
<td colspan=3>
A short, text-based summary of changes to the protocol can be found in the
<A HREF="NEWS.txt">NEWS.txt</A> file.  A <A HREF="project.html">general
description of the project</A> is also available.
</td></tr>

<tr><td colspan=4>&nbsp;</td></tr>

<tr>
<td colspan=4>
<font size=+1 color="#0000BB"><b>Monitor Source:</b></font></td>
</tr>

<tr>
<td></td>
<td colspan=3>
The Monitor source is available at <A HREF="monitor-2.9.tar.gz">here</A>.
</td></tr>

<tr><td colspan=4>&nbsp;</td></tr>

<tr>
<td colspan=4>
<font size=+1 color="#0000BB"><b>Mailing List:</b></font></td></tr>

<tr>
<td></td>
<td colspan=3>
All discussion and announcements for the I-Wars project will take place on
the mailing list.  If you are participating in this project
<STRONG>it is imperative</STRONG> that you be on this mailing list.
Important announcements about the project will be made here.  In addition,
questions will be answered here concerning all aspects of the project.
<P>
<STRONG>Questions that are not of a private nature sent via private email
will most likely be ignored.</STRONG> Use the mailing list to ask all
general (non private) questions about the project.  Don't be shy or
embarrassed---posting here is the quickest way to get an answer!
<P>
To subscribe to the mailing list, send a message with subject
<PRE>
subscribe
</PRE>
and one line body that reads:
<PRE>
subscribe
</PRE>
to the address:
<A HREF="mailto:project-request@helios.ececs.uc.edu">project-request@helios.ececs.uc.edu</A>.
<P>
You will receive a confirmation of your subscription.
<P>
When posting to the list, <STRONG>as stated in the subscription
information</STRONG> be sure to post to the address
<A HREF="mailto:project@helios.ececs.uc.edu">project@helios.ececs.uc.edu</A>.
Posts meant for the list that are incorrectly sent to the request address
will in all likelihood be ignored.
</td></tr>

<tr><td colspan=4>&nbsp;</td></tr>

<tr><td colspan=4>
<font size=+1 color="#0000BB"><b>What Is Not Covered:</b></font></td></tr>

<tr><td></td><td colspan=3>
This protocol defines precisely the interactions that should happen between
the Monitor and Players.  However, Player-to-Player communications are left
completely left up to Players.   the Directive/Command framework defined
here would be completely reasonable for use in a Player-to-Player
communication protocol.
<P>
Player-to-Player command <STRONG>should be worked out</STRONG> among all the
players.  The game can be played effectively without any Player-to-Player
communication protocol (per se); however Players are encouraged to use the
mailing list to decide on a reasonable Player-to-Player protocol.
<P>
You should check this site frequently from now on to get information on the
updated protocols.  Future protocols will be 100% backwards-compatible with
this one.  Newer protocols will only add new functionality.
</td></tr>

<tr><td colspan=4>&nbsp;</td></tr>

<tr><td colspan=4><hr width=80%></td></tr>

<tr><td colspan=4>
<center>
<font size=+2 color="#0000BB"><b>Overview of The I-Wars Protocol</b></font>
</center>
</td></tr>

<tr><td colspan=4>
<b><font color="#0000BB" size=+1>Communication Modes:</font></b></td></tr>

<tr><td></td><td colspan=3>
The protocol has two modes of communication: <EM>Directive</EM> and
<EM>Command</EM> modes.  Your application must support both of these modes
for a variety of cases, which are described herein.
</td></tr>

<tr><td colspan=4>&nbsp;</td></tr>

<tr><td colspan=4>
<b><font color="#0000BB" size=+1>Communication Styles:</font></b></td></tr>

<tr><td></td><td colspan=3>
There are three styles of communication that can occur in the game:
<UL>
<LI> <EM>Player A to Monitor</EM> (Player A makes active connection to
                                   Monitor's server)
<LI> <EM>Monitor to Player A</EM> (Monitor makes active connection to
                                   Player A's server)
<LI> <EM>Player A to Player B</EM> (Player A makes active connection
                                    to Player B's server)
</UL>
<P>
In all cases, regardless of the direction of the connection, the Monitor
always operates in <EM>Directive</EM> mode, and the player in question is
required to operate in <EM>Command</EM> mode.
<P>
In the case of two players, the player who initiated the connection (above,
this would be Player A) will be in <EM>Directive</EM> mode while the other
player is in <EM>Command</EM> mode.  (Note that this is the only official
statement about Player-to-Player communications here; Players must work out
Player-to-Player communications themselves.)
</td></tr>

<tr><td colspan=4>&nbsp;</td></tr>

<tr><td colspan=4>
<b><font color="#0000BB" size=+1>Server and Clients:</font></b>
</td></tr>

<tr><td></td><td colspan=3>
Each player must have one server process (which may "spin off" many passive
client processes), and at least one active client process.
<P>
The server process listens as a <CODE>ServerSocket()</CODE> on a particular
port, awaiting connections.  The server must be capable of handling more
than one connection at a time.  This is of the utmost importance, since the
Monitor makes frequent (and sometimes simultaneous!) connections to the
server process.  Therefore, each connection should generate a passive client
process to handle that connection.  (<EM>Hint: Use Threads!</EM>)
<P>
(Note that some might call this "passive client" something different.
Basically, it is a separate "handler" that takes a socket connection made to
your server port, and talks to it in command mode.  Call this what you
will---but this is what it must do.)
<P>
Each player also must have at least one active client process, but can have
as many as the programmer desires.  Active client processes are used to make
proactive connections to the server ports of the Monitor and other players.
At startup, the very first task of the first active client process will be
to make a connection to the Monitor's server and go through a
<EM>Registration Transaction</EM>.
<P>
Note that active client processes should not interfere with (although they
may need to internally communicate with) the player's own server process.
They should be almost completely independent of each other.  Clearly, some
communication of internal state will be required, but on the whole, they
should operate independently (<EM>Hint: Use Threads!</EM>).
<P>
Active client processes differ from passive client processes in one key
area.  The passive client process is started only when someone (the Monitor
or another Player) makes a connection to the Player's server port and makes
some requests.  The active client process is that which goes out and makes
connections to other Players server port and to the Monitor's server port.
<P>
The server process for the Monitor will always be on the machine
<CODE>helios.ececs.uc.edu</CODE> on port <CODE>8180</CODE>.  In addition, all
active client processes from the Monitor will generate from
<CODE>helios.ececs.uc.edu</CODE>.
</td></tr>

<tr><td colspan=4>&nbsp;</td></tr>
<tr><td colspan=4><HR width="50%"></td></tr>

<tr><td colspan=4>
<CENTER>
<font size=+2 color="#0000BB"><b>Directive Mode</b></font>
</CENTER>
</td></tr>

<tr><td></td><td colspan=3>
In this discussion of Directive Mode, the sender is considered the process
in Directive mode, while the receiver is the process to whom the sender is
communicating to.  As required by the protocol, if the sender is in
Directive Mode, the receiver must be in Command mode.
<P>
<b><font color="#0000BB" size=+1>Overview:</font></b>
<p>
Directive mode is the mode that the Monitor is always in, and the
mode that a player's active client processes must be in when connecting to
other players.  
<P>
When in Directive mode, a process will send a series of <EM>Message
Groups</EM> across the socket.  Each message group consists of one or more
<EM>Directives</EM>.  Each Directive is on a separate line.  After each
Message Group, the sender waits for the receiver to issue a single
<EM>Command</EM>.  (More information about Commands is below).

<P>
<b><font color="#0000BB" size=+1>The Directives:</font></b>
<p>

(Note that all interactions are <STRONG>case insensitive</STRONG>).

All Directives are in the form:
<BR>
<CODE>
DIRECTIVE: ARG1 ARG2 ... ARGN STRING
</CODE>
<BR>
<CODE>ARG1</CODE> through <CODE>ARGN</CODE> and/or <CODE>STRING</CODE> are
optional or not depending on each particular Directive.  A given
<CODE>ARGI</CODE> will be guaranteed to contain no whitespace.  Sometimes, a
given <CODE>ARGI</CODE> will be guaranteed to always be the <STRONG>exact
same token</STRONG>.  In these cases, that literal token will be listed in
the tables below.
<P>
<CODE>STRING</CODE> is usually a free-form string, which can contain
whitespace.
<P>
Directives are always terminated by a newline.
<P>
<TABLE  bgcolor="#f0f0f0" border=1 cellpadding=5 cellspacing=5>
<TR align=center>
<TH width="20%">Directive</TH>
<TH width="80%">Description</TH>
</TR>
<TR>
<TD width="20%">
<CODE>WAITING:</CODE>
</TD>
<TD width="80%">
Indicates that the current Message Group is complete, and the sender awaits
a Command from the receiver.
</TD>
</TR>

<TR>
<TD width="20%">
<CODE>REQUIRE: ARG1</CODE>
</TD>
<TD width="80%">
Indicates that the sender is demanding that the next Command from receiver
be <CODE>ARG1</CODE>.  If the receiver sends some Command besides
<CODE>ARG1</CODE>, the most likely result will be a
<CODE>COMMAND_ERROR:</CODE> Directive, and another <CODE>REQUIRE:
ARG1</CODE> Directive in the next Message Group.
</TD>
</TR>

<TR>
<TD width="20%">
<CODE>COMMAND_ERROR: STRING</CODE>
</TD>
<TD width="80%">
Indicates that an error occurred during the processing of the last Command.
This could be because of invalid arguments, incorrect number of arguments,
an unexpected Command (e.g., if a different Command is currently
<CODE>REQUIRE</CODE>d), or because a Command is not yet implemented.  The
<CODE>STRING</CODE> will be a diagnostic error message.
<CODE>COMMAND_ERROR</CODE> only appears in a Message Group if there was an
error with the last command.</CODE>
</TD>
</TR>

<TR>
<TD width="20%">
<CODE>COMMENT: STRING</CODE>
</TD>
<TD width="80%">
This Directive is used to give verbose output on the operation of various
Commands, and to give general feedback about a variety of things.
<CODE>STRING</CODE> is completely free-form, and more than likely will only
be useful to human eyes for debugging.  Not every Message Group is guaranteed
to have a <CODE>COMMENT</CODE> directive.
</TD>
</TR>

<TR align>
<TD width="20%">
<CODE>RESULT: ARG1 STRING</CODE>
</TD>
<TD width="80%">
This Directive is used to return results from the last Command issued by the
receiver.  <CODE>ARG1</CODE> will be the Command for which these are
results.  <CODE>STRING</CODE>, in this case, <STRONG>will not be
free-form</STRONG>.  Rather, it will be in the format as described by the
result format for the Command, <CODE>ARG1</CODE>.  In many cases,
particularly with those commands that generate no results,
<CODE>STRING</CODE> will be the empty string.  Note that the
<CODE>RESULT:</CODE> Directive does not appear when there is an error
executing a given command.  See the <CODE>COMMAND_ERROR</CODE> Directive.
</TD>
</TR>


<TR>
<TD width="20%">
<CODE>PLAYER_PASSWORD_CHECKSUM: ARG1</CODE>
</TD>
<TD width="80%">
This Directive is sent by the Monitor to authenticate to the player.
<CODE>ARG1</CODE> is a SHA-1 digest of the player's password, represented in
hexadecimal.  This directive is most useful when the player receives a
connection on its server port.  The Monitor will always have this Directive
in the first Message Group that it sends during an active client connection.
However, it is up to the player to verify that <CODE>ARG1</CODE> does, in
fact, authenticate the Monitor properly.  <STRONG>Note that some players
will most surely be attempting to impersonate the Monitor!</STRONG>
</TD>
</TR>

<TR>
<TD width="20%">
<CODE>WAR_DECLARATION: ARG1</CODE>
</TD>
<TD width="80%">
This Directive is sent by the Monitor to <CODE>Player_B</CODE>, on behalf of
<CODE>Player_A</CODE>.  <CODE>ARG1</CODE> is the identity of the
<CODE>Player_A</CODE>, who is declaring war on <CODE>Player_B</CODE>.  Note
that <CODE>Player_B</CODE> will always be the receiver of the Directive,
otherwise the Directive is basically meaningless.  This Directive usually
occurs in a message group with a <CODE>REQUIRE: WAR_DEFEND</CODE>.
</TD>
</TR>

<TR>
<TD width="20%">
<CODE>TRADE: ARG1 ARG2 ARG3 for ARG5 ARG6 ARG7</CODE>
</TD>
<TD width="80%">
This Directive is sent by the Monitor to <CODE>Player_B</CODE>, on behalf of
<CODE>Player_A</CODE>.  <CODE>ARG1</CODE> is the identity of the Player
asking for the trade (e.g., <CODE>PLAYER_1</CODE>).  <CODE>ARG2</CODE> is the
resource that the <CODE>PLAYER_1</CODE> would like to trade.
<CODE>ARG3</CODE> is the amount (an integer) that <CODE>PLAYER_1</CODE> is
offering.  <CODE>ARG5</CODE> is the identity of the Player that
<CODE>Player_A</CODE> would like to trade to (e.g., <CODE>Player_B</CODE>).
Note that <CODE>Player_B</CODE> will always be the receiver of the
Directive, otherwise the Directive is basically meaningless.
<CODE>ARG6</CODE> is the resource which is being requested from
<CODE>Player_B</CODE>.  <CODE>ARG7</CODE> is the amount of that resource
that is being requested.
</TD>
</TR>
<TR>

<TD width="20%">
<CODE>WAR_TRUCE_OFFERED: ARG1 to ARG3 ARG4 ARG5 ARG6 ARG7 ... ARGN
</CODE>
</TD>
<TD width="80%">
This Directive is sent by the Monitor to <CODE>Player_B</CODE>, on behalf of
<CODE>Player_A</CODE>.  <CODE>ARG1</CODE> is the identity of the Player
asking for the truce (e.g., <CODE>Player_A</CODE>.  <CODE>ARG2</CODE> is
always "to".  <CODE>ARG3</CODE> is the identity of the Player who will
benefit from the truce (i.e., <CODE>Player_A</CODE>).  <CODE>ARG3</CODE> is
the string representing a resource, and <CODE>ARG4</CODE> is the amount of
this resource offered.  This continues through the rest of the directive,
which odd-number arguments being the resource and even numbers being the
amount offered.  If the truce is accepted, the amounts of those resources
will be transferred from <CODE>Player_A</CODE> to <CODE>Player_B</CODE>.
<!---Note that <CODE>Player_B</CODE> will always be the receiver of the-->
</TD>
</TR>



</TABLE>

<P>
<b><font color="#0000BB" size=+1>Message Groups:</font></b>
<p>
A Message Group is defined as a sequence of N Directives, one per line.
A Message Group also has the following properties:
<UL>
<LI> N &gt;= 1
<LI> Each line contains one and only one Directive, each terminated by a
     newline character
<LI> The last Directive is <CODE>WAITING:</CODE>, unless the sender
     is terminating the connection, in which case the Message Group will not
     end with <CODE>WAITING:</CODE>, but instead will end with the an end of
     file marker.
</UL>
</td></tr>

<tr><td colspan=4><HR width="50%"></td></tr>

<tr><td colspan=4>
<CENTER>
<font size=+2 color="#0000BB"><b>Command Mode</b></font>
</CENTER>
</td></tr>

<tr><td></td><td colspan=3>
In this discussion of Command Mode, the sender is considered the process
in Command mode, while the receiver is the process to whom the sender is
communicating to.  By requirements of the protocol, if the sender is in
Command Mode, the receiver must be in Directive mode.
<P>
<P>
<b><font color="#0000BB" size=+1>The Commands:</font></b>
<p>

(Note that all interactions are <STRONG>case insensitive</STRONG>).

All Commands are in the form:
<BR>
<CODE>
COMMAND ARG1 ARG2 ... ARGN
</CODE>
<BR>
<CODE>ARG1</CODE> through <CODE>ARGN</CODE> are optional or not, depending
on each particular Command.  A given <CODE>ARGI</CODE> will be guaranteed to
contain no whitespace.  Sometimes, a given <CODE>ARGI</CODE> will be
guaranteed to always be the <STRONG>exact same token</STRONG>.  In these
cases, that literal token will be listed in the tables below.
<P>
Commands are always terminated by a newline.
<P>
The following table of commands are used in all transactions:
<p>

<TABLE  bgcolor="#f0f0f0" border=1 cellpadding=5 cellspacing=5>
<TR align=center>
<TH width="10%">Command</TH>
<TH width="55%">Description</TH>
<TH width="35%">Result</TH>

<TR>
<TD width="10%">
<CODE>IDENT ARG1 ARG2</CODE>
</TD>
<TD width="55%">
This command is used to send the sender's identity to the receiver.  A
player's identity is not a secret---like a username, it is the method by
which others (including the Monitor) identify the player.  <CODE>ARG1</CODE>
is the identity of the username.  <CODE>ARG2</CODE> is optional.  If
<CODE>ARG2</CODE> is sent, it should be the Player's portion that is needed
to do shared-secret discovery.  (See the Cryptography section below for
details.)
</TD>
<TD width="35%">
The result is<BR>
 <CODE>RESULT: IDENT ARG1</CODE><BR>
<CODE>ARG1</CODE> is optional, and only appears if cryptography was
requested.  If it was requested, then <CODE>ARG1</CODE> will be the public
key that the Player needs to do shared-secret discovery. (See the
Cryptography section below for details.)  Note, that since the IDENT command
can be used in Player-to-Player communications, Players who wish to be sure
that they can communicate with everyone must implement this encryption, and
 give <CODE>ARG1</CODE> back properly if cryptography was requested by the
 <CODE>IDENT</CODE> command.
</TD>
</TR>

<TR>
<TD width="10%">
<CODE>QUIT</CODE>
</TD>
<TD width="55%">
This command terminates the current connection.
</TD>
<TD width="35%">
The result is<BR>
 <CODE>RESULT: QUIT</CODE>

<BR>
  In addition, note that the Message
 Group that follows this Command will not contain the <CODE>WAITING:</CODE>
 Directive, as the connection will be closed.

</TD>
</TR>

</TABLE>
<P>
The following Commands should be used only in transmissions from the
Player to the Monitor (however, there is no Monitor-imposed penalty for
Players who try to use these Commands with other Players):
<p>

<TABLE  bgcolor="#f0f0f0" border=1 cellpadding=5 cellspacing=5>
<TR align=center>
<TH width="10%">Command</TH>
<TH width="55%">Description</TH>
<TH width="35%">Result</TH>
<TR>
<TD width="10%">
<CODE>PASSWORD ARG1</CODE>
</TD>
<TD width="55%">
This command is used to transmit the player's password to the monitor.
<CODE>ARG1</CODE> is the player's password.  The Monitor sometimes sends
<CODE>REQUIRE: PASSWORD</CODE> after a successful <CODE>IDENT</CODE>
command.  Note that this command is a bootstrap for secure communications
with the Monitor later, so the player should use <STRONG>other
means</STRONG> to verify that the request definitely came from the Monitor.
</TD>
<TD width="35%">
The result is <BR>
<CODE>RESULT: PASSWORD STRING</CODE>
<BR>
which is sent in the
Message Group following the Command invocation.  <CODE>STRING</CODE> is an
alphanumeric string with no whitespace that is the
<STRONG><EM>player-specific</STRONG></EM> monitor password (sometimes called
a "cookie").  This password ("cookie") is <STRONG>different</CODE> from the
player's own password.  This password ("cookie") should be used with the
<CODE>ALIVE</CODE> command to identify the player to the Monitor.
</TD>
</TR>

<TR>
<TD width="10%">
<CODE>CHANGE_PASSWORD ARG1 ARG2</CODE>
</TD>
<TD width="55%">
This command is used to request a change in the player password and the
player-specific monitor password.  <CODE>ARG1</CODE> is the player's old
password (the one currently in use).  <CODE>ARG2</CODE> is the new password
that the player would like to use from this time forward.  Note that the
password is only changed if the command successfully returns a
<CODE>RESULT:</CODE> Directive in the next Message Group.
</TD>
<TD width="35%">
The result is 
<BR>
<CODE>RESULT: CHANGE_PASSWORD STRING</CODE>
<BR>
 which is sent in the Message Group following the Command invocation.
<CODE>STRING</CODE> is an alphanumeric string with no whitespace that is the
<STRONG><EM>player-specific</STRONG></EM> monitor password (sometimes called
a "cookie").  This new player-specific monitor password <STRONG>will be
different from before</STRONG>.  The <CODE>CHANGE_PASSWORD</CODE> command
not only allows the player to change the player password, but also
automatically changes the player-specific monitor password ("cookie").  Note
that Players should be careful with this command.  It is recommended that it
be sent <STRONG>first</STRONG> in any set of transactions.  Some Players
have abused the fact that the Monitor gives 180 seconds for a connection,
however, connections should <STRONG>never</STRONG> last that long.  If the
<CODE>CHANGE_PASSWORD</CODE> command is sent at the end of one of these
"marathon" connections, Players may be cut off before they can receive the
new Monitor password, and may be locked out of the game.
</TD>
</TR>

<TR>
<TD width="10%">
<CODE>SYNTHESIZE ARG1</CODE>
</TD>
<TD width="55%">
This command is used to synthesize a complex resource.  The complex
resources are <STRONG>WEAPONS</STRONG>, <STRONG>COMPUTERS</STRONG>, and
<STRONG>VEHICLES</STRONG>.  <CODE>ARG1</CODE> should be the resource to
synthesize.  Be sure that the name of the resource matches the name given by
the <CODE>PLAYER_STATUS</CODE> command.  See the table in the "Synthesize"
section for more information about what raw resources are needed to
synthesize the complex resources.
</TD>
<TD width="35%">
The result is <BR>
<CODE>RESULT: SYNTHESIZE STRING</CODE>
<BR>
 which is sent in the
Message Group following the Command invocation.  <CODE>STRING</CODE> 
is<BR>
 <CODE>RESOURCE holdings increased by one</CODE><BR>, where
<CODE>RESOURCE</CODE> is the resource that was increased.
A <CODE>COMMAND_ERROR</CODE> is sent if the resource could not be
synthesized for any reason.
</TD>
</TR>

<TR>
<TD width="10%">
<CODE>HOST_PORT ARG1 ARG2</CODE>
</TD>
<TD width="55%">
This Command is always sent by an active client process of a player to the
Monitor.  It is used by the sender to inform receiver (usually the Monitor)
what hostname and port the sender currently lives on.  <CODE>ARG1</CODE>
should be the fully qualified DNS name of the host where the server process
of the sender is running. <CODE>ARG2</CODE> should be the integer port
number (between 2048 and 65000, inclusive) where the server Socket for the
sender is running on.  Note: This Command <STRONG>will only</STRONG> be
successful if there <STRONG>is currently</STRONG> a server process for the
sender running on the given hostname and port.
</TD>
<TD width="35%">
The result is
<BR>
 <CODE>RESULT: HOST_PORT HOST_NAME PORT</CODE>
<BR>
<CODE>HOST_NAME</CODE> is the fully qualified DNS hostname that the Monitor
was able to identify you as, and <CODE>PORT</CODE> is the port where you
live.
</TD>
</TR>

<TR>
<TD width="10%">
<CODE>SIGN_OFF</CODE>
</TD>
<TD width="55%">
This command is used to tell the Monitor to "forget about the Player".  The
Monitor "forgets about the Player" in two ways.  First, it forgets what host
and port the Player's server is on.  This means that the
<CODE>HOST_PORT</CODE> will be <CODE>REQUIRE:</CODE> the next time the
Player connects to the Monitor with an active client connection.  In
addition, the Monitor will "forget about the Player" by invalidating the
current Player-specific Monitor password for the Player.  This means that
the Player will get a <CODE>PASSWORD</CODE> command <CODE>REQUIRE:</CODE>
the next time that the Player connects to the Monitor with an active client
connection.  <STRONG>Note that if you execute this command, the Monitor will
consider that you are not alive, until you again send the
<CODE>HOST_PORT</CODE> command</STRONG>.
</TD>
<TD width="35%">
The result is
<BR>
 <CODE>RESULT: SIGN_OFF</CODE>
<BR> 
in the Message Group following the Command invocation.
</TD>
</TR>

<TR>
<TD width="10%">
<CODE>PLAYER_STATUS</CODE>
</TD>
<TD width="55%">
This Command is used to check on the status of the sender's wealth.
</TD>
<TD width="35%">
The result is
<BR>
 <CODE>RESULT: PLAYER_STATUS STRING</CODE>
<BR>
 which is sent in
the Message Group following the Command invocation.  The string is in the
format:
<BR>
<CODE>RESOURCE_0 AMOUNT_0 RESOURCE_1 AMOUNT_1 ... RESOURCE_9 AMOUNT_9
</CODE>
<BR>
where RESOURCE_I is the alphanumeric string of one of the 10 resources, and
AMOUNT_I is the amount of that resource the sender currently has.
</TD>
</TR>

<TR>
<TD width="10%">
<CODE>ALIVE ARG1</CODE>
</TD>
<TD width="55%">
This Command is sent to indicate to the Monitor that the
Player is alive.  <CODE>ARG1</CODE> should be the player-specific
monitor password ("cookie") that was given to the Player by the Monitor
as a <CODE>RESULT:</CODE> of the <CODE>PASSWORD</CODE> Command.  If
<CODE>ARG1</CODE> is not the write password ("cookie"), a
<CODE>COMMAND_ERROR:</CODE> will and the Player will not be counted as
alive.
</TD>
<TD width="35%">
The result is
<BR>
 <CODE>RESULT: ALIVE Identity has been verified</CODE>
<BR>
</TD>
</TR>

<TD width="10%">
<CODE>TRADE_REQUEST ARG1 ARG2 ARG3 for ARG5 ARG6 ARG7</CODE>
</TD>
<TD width="55%">
This command is used by the initiator of a trade to ask the Monitor to
confirm the trade, by making a request to the other player.  The arguments
to <CODE>TRADE_REQUEST</CODE> are exactly the same as those to the
<CODE>TRADE:</CODE> directive.  Note that <CODE>ARG5</CODE> may be
<CODE>MONITOR</CODE>.  In this case, the Player is requesting a trade with
the Monitor itself.  If the Monitor has the requested materials available,
the Monitor approves trades that at current market values, plus a percentage
mark-up.

</TD>
<TD width="35%">
The result is
<BR><CODE>RESULT: TRADE_REQUEST ARG1</CODE>
<BR>  <CODE>ARG1</CODE> is
either <CODE>ACCEPTED</CODE>, <CODE>REJECTED</CODE>, or
<CODE>NOT_ALIVE</CODE>.  All of which refer to the status of the Player with
whom this trade was requested.  If <CODE>ARG1</CODE> is
<CODE>ACCEPTED</CODE>, then the Player can expect her wealth to be changed
to reflect the trade.
</TD>
</TR>

<TD width="10%">
<CODE>TRADE_RESPONSE ARG1</CODE>
</TD>
<TD width="55%">
This command is used to either accept or reject a trade request.  This
command is most probably used in response to a Message Group that contained
the <CODE>TRADE:</CODE> Directive (and probably a <CODE>REQUIRE:
TRADE_RESPONSE</CODE> Directive as well).  

<CODE>ARG1</CODE> is either <CODE>ACCEPT</CODE> or <CODE>DECLINE</CODE>.
</TD>
<TD width="35%">
The result is
<BR>
<CODE>RESULT: TRADE_RESPONSE</CODE>
<BR>  Depending on whether the
Player accepted or declined the trade (and, if a Monitor approval was
given), the Player's wealth will be changed. 
</TD>
</TR>

<TD width="10%">
<CODE>WAR_DECLARE ARG1 ARG2 ARG3 ARG4 ARG5</CODE>
</TD>
<TD width="55%">
This command is used by <CODE>Player_A</CODE> to declare war on
<CODE>Player_B</CODE>.  <CODE>ARG1</CODE> should be the identity of
<CODE>Player_B</CODE>.  <CODE>ARG2</CODE> should be the host where
<CODE>Player_B</CODE> lives, and <CODE>ARG3</CODE> should be the port on
which <CODE>Player_B</CODE> is listening.  <CODE>ARG4</CODE> is the number
of weapons that <CODE>Player_A</CODE> would like to commit to this war, and
<CODE>ARG5</CODE> is the number of vehicles that <CODE>Player_A</CODE> would
like to commit to this war.  If this host and/or port for
<CODE>Player_B</CODE> is wrong, <CODE>Player_A</CODE> will automatically
loose some percentage of the weapons and vehicles committed, and the war
will not be started (in other words, <CODE>Player_A</CODE> must know where
<CODE>Player_B</CODE> "lives" before declaring war.  Finally, note that the
given weapons and vehicles will be tied up in that war until end of the war.
A <CODE>COMMAND_ERROR</CODE> will be in the resulting Message Group if
<CODE>Player_B</CODE> cannot be found, or if <CODE>Player_A</CODE> has less
weapons and/or vehicles than were specified.
</TD>
<TD width="35%">
The result is
<BR>
<CODE>RESULT: WAR_DECLARE War begun with ARG1</CODE>
<BR>
</TD>
</TR>



<TD width="10%">
<CODE>WAR_DEFEND ARG1 ARG2</CODE>
</TD>
<TD width="55%">
This command is used to declare defending parameters for a war that was
declared via a <CODE>WAR_DECLARATION:</CODE> directive.  <CODE>ARG1</CODE>
is the number of weapons the Player wishes to use in this war.
<CODE>ARG2</CODE> is the number of vehicles the player wishes to use in this
war.  This command is most probably used in response to a Message Group that
contained the <CODE>WAR_DECLARATION:</CODE> Directive (and probably a
<CODE>REQUIRE: WAR_DECLARATION</CODE> Directive as well).
</TD>
<TD width="35%">
The result is
<BR>
<CODE>RESULT: WAR_DEFEND</CODE>
<BR>
</TD>
</TR>

<TD width="10%">
<CODE>WAR_TRUCE_OFFER ARG1 to ARG3 ARG4 ARG5 ARG6 ARG7 ... ARGN</CODE>
</TD>
<TD width="55%">
This command is used by the initiator of a trade to ask the Monitor to
confirm a truce, by making a request to the other player.  The arguments
to <CODE>WAR_TRUCE_OFFER</CODE> are exactly the same as those to the
<CODE>WAR_TRUCE_OFFERED:</CODE> directive.
</TD>
<TD width="35%">
The result is <BR><CODE>RESULT: WAR_TRUCE_OFFER ARG1</CODE> <BR>
<CODE>ARG1</CODE> is either <CODE>ACCEPTED</CODE>, <CODE>REJECTED</CODE>,
<CODE>NOT_ALIVE</CODE>, or <CODE>WAR_OVER</CODE>. If <CODE>ARG1</CODE> is
<CODE>ACCEPTED</CODE>, then the Player can expect her wealth to be changed
to reflect the truce terms.  A <CODE>COMMAND_ERROR</CODE> occurs if a war is
not active between the two parties, an invalid resource name is given, or if
the player who has offered the truce does not have sufficient resources.
Note that weapons and vehicles already tied up in the war cannot be used in
a war trade agreement.
</TD>
</TR>

<TD width="10%">
<CODE>WAR_TRUCE_RESPONSE ARG1</CODE>
</TD>
<TD width="55%">
This command is used to either accept or reject a truce request.  This
command is most probably used in response to a Message Group that contained
the <CODE>WAR_TRUCE_OFFERED:</CODE> Directive (and probably a <CODE>REQUIRE:
WAR_TRUCE_RESPONSE</CODE> Directive as well).  

<CODE>ARG1</CODE> is either <CODE>ACCEPT</CODE> or <CODE>DECLINE</CODE>.
</TD>
<TD width="35%">
The result is
<BR>
<CODE>RESULT: WAR_TRUCE_RESPONSE</CODE>
<BR>  Depending on whether the
Player accepted or declined the trade (and, if a Monitor approval was
given), the Player's wealth will be changed. 
</TD>
</TR>

<TD width="10%">
<CODE>WAR_STATUS ARG1</CODE>
</TD>
<TD width="55%">
This command is used find the status of current or recently fought wars.
<CODE>ARG1</CODE> is the identity of <CODE>Player_B</CODE>, the player
against whom the requestor <CODE>Player_A</CODE> wishes to see the war
status.  A <CODE>COMMAND_ERROR</CODE> is sent in the resulting Message Group
if <CODE>Player_A</CODE> has never been at war with <CODE>Player_B</CODE>
</TD>
<TD width="35%">
The result is
<BR>
<CODE>RESULT: WAR_STATUS aggressor ARG2 defender ARG4 winner
ARG6 battles ARG8 status ARG10 weapons ARG12 vehicles ARG14</CODE>
<BR>
<CODE>ARG2</CODE> is the identity of the aggressor in this war.
<CODE>ARG4</CODE> is the identity of the defender in this war.
<CODE>ARG6</CODE> will be the identity of the winner,  <CODE>TRUCE</CODE>
is a truce was found, or <CODE>NONE</CODE> if the war still continues.
<CODE>ARG8</CODE> will be an integer that represents the number of battles
fought thus far in this war. 
<CODE>ARG10</CODE> will be <CODE>COMPLETED</CODE> if the war is over,  or
<CODE>ACTIVE</CODE> if the war is still active.
<CODE>ARG12</CODE> is the number of weapons that <CODE>Player_A</CODE> (you)
has committed to this war.
<CODE>ARG14</CODE> is the number of vehicles that <CODE>Player_A</CODE> (you)
has committed to this war.
Note: the number of vehicles and weapons committed to wars are not part of
your <CODE>PLAYER_STATUS</CODE> total.
</TD>
</TR>


<TD width="10%">
<CODE>GET_GAME_IDENTS</CODE>
</TD>
<TD width="55%">
This command is used to get a list of identities of Players in the current
game.  This is useful, for example, if you want to know who can be traded
with.
</TD>
<TD width="35%">
The result is
<BR>
<CODE>RESULT: GET_GAME_IDENTS ARG1 ... ARGN</CODE> 
<BR> There
will be <CODE>N</CODE> arguments in the response.  Each argument will be the
identity of another Player who is currently in the game. 
</TD>
</TR>

<TD width="10%">
<CODE>RANDOM_PLAYER_HOST_PORT</CODE>
</TD>
<TD width="55%">
This command is used to ask the Monitor for a host port of some random
identity.  This is useful when a Player wishes to go to war with another
Player, as in these cases, it is necessary to know the host and port of the
Player  to be fought. A <CODE>COMMAND_ERROR</CODE> occurs if you have
already asked for a random Player host and port recently.
</TD>
<TD width="35%">
The result is
<BR>
<CODE>RESULT: RANDOM_PLAYER_HOST_PORT ARG1 ARG2 ARG3</CODE>
<BR>
<CODE>ARG1</CODE> will be the identity of the Player, <CODE>ARG2</CODE> will
be the most recent host on which that Player has been seen, and
<CODE>ARG3</CODE> will be the port on which that Player lives and/or the
host and port where that player was most recently seen.
</TD>
</TR>

<TD width="10%">
<CODE>PLAYER_HOST_PORT ARG1</CODE>
</TD>
<TD width="55%">
This command is used to ask the Monitor for a host port of some given
Player's identity.  The command <STRONG>costs one computer
resource</STRONG>.  A <CODE>COMMAND_ERROR</CODE> occurs if the Player
issuing the command does not have adequate computer resources.  A
<CODE>COMMAND_ERROR</CODE> also occurs if the identity is not known and/or
the requested Player is not currently alive.  Note that the computer
resource is taken <STRONG>even if</STRONG> the identity is not known or the
Player is not alive.
</TD>
<TD width="35%">
The result is
<BR>
<CODE>RESULT: PLAYER_HOST_PORT ARG1 ARG2 ARG3</CODE>
<BR>
<CODE>ARG1</CODE> will be the identity of the Player, <CODE>ARG2</CODE> will
be the most recent host on which that Player has been seen, and
<CODE>ARG3</CODE> will be the port on which that Player lives and/or the
host and port where that player was most recently seen.
</TD>
</TR>

<TD width="10%">
<CODE>PLAYER_STATUS_CRACK ARG1 ARG2</CODE>
</TD>
<TD width="55%">
This command is used to make an attempt to get the player status information
of an enemy Player.  <CODE>ARG1</CODE> is the identity of the Player whose
status to crack.  <CODE>ARG2</CODE> is the number of computer resources to
spend on this attempt.  <STRONG>The computer resources will be lost,
regardless of whether or not the crack attempt succeeds</STRONG>.  The more
computer resources committed, the greater the chance of success. A
<CODE>COMMAND_ERROR</CODE> occurs if the Player issuing the command does not
have at least the amount of computer resources requested.  A
<CODE>COMMAND_ERROR</CODE> also occurs if the identity is not known.
</TD>
<TD width="35%">
The result is
<BR>
<CODE>RESULT: PLAYER_STATUS_CRACK ARG1 ARG2 STRING</CODE>
<BR>
<CODE>ARG1</CODE> will be the identity of the Player whose status was to be
cracked.  <CODE>ARG2</CODE> will be either <CODE>SUCCEEDED</CODE> or
<CODE>FAILED</CODE>.  If <CODE>ARG2</CODE> is <CODE>SUCCEEDED</CODE>, then
<CODE>STRING</CODE> will equivalent to the result string for the
<CODE>PLAYER_STATUS</CODE> command, however, the status will of course be
for Player, <CODE>ARG1</CODE>.
</TD>
</TR>

<TD width="10%">
<CODE>PLAYER_MONITOR_PASSWORD_CRACK ARG1 ARG2</CODE>
</TD>
<TD width="55%">
This command is used to make an attempt to crack the Monitor password of
another player.  <CODE>ARG1</CODE> is the identity of the Player whose
Monitor password to crack.  <CODE>ARG2</CODE> is the number of computer
resources to spend on this attempt.  <STRONG>The computer resources will be
lost, regardless of whether or not the crack attempt succeeds</STRONG>.  The
more computer resources committed, the greater the chance of success. A
<CODE>COMMAND_ERROR</CODE> occurs if the Player issuing the command does not
have at least the amount of computer resources requested.  A
<CODE>COMMAND_ERROR</CODE> also occurs if the identity is not known.
</TD>
<TD width="35%">
The result is
<BR>
<CODE>RESULT: PLAYER_MONITOR_PASSWORD_CRACK ARG1 ARG2 ARG3</CODE>
<BR>
<CODE>ARG1</CODE> will be the identity of the Player whose Monitor password
was to be cracked.  <CODE>ARG2</CODE> will be either <CODE>SUCCEEDED</CODE>
or <CODE>FAILED</CODE>.  If <CODE>ARG2</CODE> is <CODE>SUCCEEDED</CODE>,
then <CODE>ARG3</CODE> will the Monitor password of <CODE>ARG1</CODE>.
Otherwise, <CODE>ARG3</CODE> will be the empty string.
</TD>
</TR>

</TABLE>
</td></tr>

<tr><td colspan=4><HR width="50%"></td></tr>

<tr><td colspan=4>
<CENTER>
<font size=+2 color="#0000BB"><b>Cryptography</b></font>
</CENTER>
</td></tr>

<tr><td></td><td colspan=3>
Players may communicate securely with the Monitor.  The Monitor implements
Diffie-Hellman shared-secret exchange to exchange a key with the Players.
This key is then used as the key for Karn symmetric encryption.   For
Diffie-Hellman to work, Players will need the proper N and G values.  We
have created a class, called <CODE>DHKeyObject</CODE> that holds these
values.  Players will be given a serialized <CODE>DHKeyObject</CODE> for each
game that is played.
<P>
Since encryption routines are difficult to implement, we are providing three
classes, <A HREF="DHEngine.java">DHEngine.java</A>, <A
HREF="DHKeyObject.java">DHKeyObject.java</A>, and <A
HREF="Cipher.java">Cipher.java</A> that Players can drop into their Player
code  to handle encryption.  Minimal instructions for plugging this code in
are provided in the comments.
<P>
Note that when using these routines, <STRONG>each line</STRONG> from the
Monitor is encrypted as a separate block of ciphertext that must be
decrypted.
</td></tr>

<tr><td colspan=4>&nbsp;</td></tr>
<tr><td colspan=4><HR width="50%"></td></tr>

<tr><td colspan=4>
<CENTER>
<font size=+2 color="#0000BB"><b>Transactions</b></font>
</CENTER>
</td></tr>

<tr><td></td><td colspan=3>
A sequence such as:
<CODE>
Message_Group_0 Command_0 Message_Group_1 Command_1 ... Message_Group_N QUIT
</CODE>
<BR>
can be categorized as a <EM>transaction</EM>.

Often, transactions can be very "free-from".  Thus, there is no formal
definition of types of transactions.
<P>
However, frequently, the Monitor will use a series of <CODE>REQUIRE:</CODE>
Directives to force a transaction to play out in a particular way.  Thus,
transactions tend to "emerge" in a particular formats.  These transactions
are not a formalized portion of the protocol, but considering the
transaction examples given here may help you consider useful designs for
your Player.
<P>
Below are some common transactions that you will probably encounter.  You
may find look at this interactions helpful to decipher how the protocol
plays out.  However, <STRONG>note</STRONG> that these are only a few of the
types of transactions that you will encounter, and they are presented for
pedagogical purposes only.  Do not assume that <EM>all</EM> transactions
will work out like this!
<P>
In the transaction examples below, text that is sent by the
<FONT color="#ff0000">Monitor is in red</FONT>.  Text that is sent by
<FONT color="green"> Player A (you) is in green</FONT>.  Text that is sent by
<FONT color="#ffa500">Player B (a rival player) is in orange</FONT>.
Finally, <FONT color="#000000">comments (things that do not appear at all
but are added to explain what is going on) appear in black</FONT>.
<P>
<b><font color="#0000BB" size=+1>Registration Transaction:</font></b>
<p>
This transaction is initiated when the active client of <FONT
color="green">Player A (you)</FONT> connects to the <FONT
color="#ff0000">Monitor</FONT> for the first time, or after having restarted
on a new hostname and/or port.  The transaction goes as follows.
<P>
<BR>
<CODE>
<FONT color="#ff0000">
COMMENT: Game Monitor Version 2.2<BR>
REQUIRE: IDENT<BR>
WAITING: <BR>
</FONT>
<FONT color="green">
Ident WHO_I_AM<BR>
</FONT>
<FONT color="#ff0000">
RESULT: IDENT
REQUIRE: PASSWORD<BR>
WAITING: <BR>
</FONT>
<FONT color="green">
Password MYLITTLESECRET<BR>
</FONT>
<FONT color="#ff0000">
RESULT: PASSWORD NRMVEXUHFELPNN<BR>
REQUIRE: HOST_PORT<BR>
WAITING: <BR>
</FONT>
</CODE>
<FONT color="#000000">
<P>
Note here the <CODE>RESULT:</CODE>.  This means that
<CODE>NRMVEXUHFELPNN</CODE> is our <FONT
color="#ff0000">Monitor</FONT> password ("cookie").  We will
need that later on.
<P>
Now, suppose that you ignored this <CODE>REQUIRE: </CODE> and sent a
different command?
<BR>
</FONT>
<CODE>
<FONT color="green">
Player_Status<BR>
</FONT>
<FONT color="#ff0000">
COMMAND_ERROR: Command, PLAYER_STATUS, was not expected in this context, please send HOST_PORT<BR>
REQUIRE: HOST_PORT<BR>
WAITING: <BR>
</FONT>
</CODE>
<FONT color="#000000">
<P>
Since you ignored the directive and did not send the command that was being
<CODE>REQUIRE:</CODE>'d, a <CODE>COMMAND_ERROR:</CODE> was generated, and a
new <CODE>REQUIRE: </CODE> of the same command has been given.  <P> Now, you
answer properly:<BR></FONT>
<CODE>
<FONT color="green">
HOST_PORT myhost.occ.uc.edu 7891<BR>
</CODE>
</FONT>
<P>
At this point, before responding to you, the <FONT
color="#ff0000">Monitor</FONT> will attempt to contact
the machine <CODE>myhost.occ.uc.edu</CODE> on port <CODE>7891</CODE>.  The
transaction that takes place on that connection will be an
<CITE>Are-You-Alive?</CODE> transaction, described below.  Once that
transaction is completed successfully on the other port.  The result you see
back on <STRONG>this</STRONG> connection is:
<BR>
<CODE>
<FONT color="#ff0000">
RESULT: HOST_PORT MYHOST.OCC.UC.EDU 7891<BR>
WAITING: <BR>
</FONT>
</CODE>
<P>
At this point, you can send any valid command, since there is no
<CODE>RESULT:</CODE> Directive in the Message Group.  
<P>
<b><font color="#0000BB" size=+1>Are-You-Alive Transaction:</font></b>
<p>
The <FONT color="#ff0000">Monitor</FONT> initiates an Are-You-Alive
Transaction frequently.  It is done on demand when the
<CODE>HOST_PORT</CODE> command is sent on a client connection to the
monitor.  In addition, the <FONT color="#ff0000">Monitor</FONT> uses the
Are-You-Alive connection to verify you are online and to determine if you
have met the requisite uptime for receiving your daily allotment of
resources.
<P>
The Are-You-Alive Transaction is initiated by a <FONT
color="#ff0000">Monitor</FONT> client to <FONT color="green">Player
A</FONT>'s server port.  Here is what the Transaction looks like:
<BR>

<CODE>
<FONT color="#ff0000">
COMMENT: Game Monitor Version 2.2<BR>
REQUIRE: IDENT<BR>
WAITING: <BR>
</FONT>
<FONT color="green">
Ident WHO_I_AM<BR>
</FONT>
<FONT color="#ff0000">
PLAYER_PASSWORD_CHECKSUM:  36c00161466dc725834a9787fc0f18497361f0a6<BR>
RESULT: IDENT
REQUIRE: ALIVE<BR>
WAITING: <BR>
</FONT>
<FONT color="green">
ALIVE NRMVEXUHFELPNN<BR>
</FONT>
<FONT color="#ff0000">
RESULT: ALIVE Identity has been verified.<BR>
REQUIRE: QUIT<BR>
WAITING: <BR>
</FONT>
<FONT color="green">
QUIT<BR>
</FONT>
<FONT color="#ff0000">
RESULT: QUIT<BR>
</FONT>
</CODE>

<P>
<b><font color="#0000BB" size=+1>Operation Transaction:</font></b>
<p>
This transaction is almost the same as the Registration Transaction.
However, note that the <CODE>HOST_PORT</CODE> command is not required, since
the <FONT
color="#ff0000">Monitor</FONT> was able to verify that you still "live" on the same port as
when you last registered.
<BR>
<CODE>
<FONT color="#ff0000">
COMMENT: Game Monitor Version 2.2<BR>
REQUIRE: IDENT<BR>
WAITING: <BR>
</FONT>
<FONT color="green">
Ident WHO_I_AM<BR>
</FONT>
<FONT color="#ff0000">
RESULT: IDENT<BR>
REQUIRE: ALIVE<BR>
WAITING: <BR>
</FONT>
<FONT color="green">
ALIVE NRMVEXUHFELPNN<BR>
</FONT>
<FONT color="#ff0000">
RESULT: ALIVE Identity has been verified.<BR>
WAITING: <BR>
</FONT>
</CODE>
<P>
Note that the Operation Transaction is frequently used when you need to get
to a point where you need to send free-form commands to the <FONT
color="#ff0000">Monitor</FONT> (e.g., <CODE>PLAYER_STATUS</CODE>).  You
should expect that most active connections you make the monitor to start out
with something like the Operation Transaction, and then leave you in a mode
where you can send any command you choose to the <FONT
color="#ff0000">Monitor</FONT>, as you see above.
 
<P>
<b><font color="#0000BB" size=+1>Operation Transaction with changed HOST_PORT:</font></b>
<p>
This transaction is a variant of the Operation Transaction discussed above.
If your host and/or port have changed, the <FONT
color="#ff0000">Monitor</FONT> will need to require the
<CODE>HOST_PORT</CODE> command again to get a the new host and/or port.
<BR>
<CODE>
<FONT color="#ff0000">
COMMENT: Game Monitor Version 2.2<BR>
REQUIRE: IDENT<BR>
WAITING: <BR>
</FONT>
<FONT color="green">
Ident WHO_I_AM<BR>
</FONT>
<FONT color="#ff0000">
RESULT: IDENT<BR>
REQUIRE: ALIVE<BR>
WAITING: <BR>
</FONT>
<FONT color="green">
ALIVE NRMVEXUHFELPNN<BR>
</FONT>
<FONT color="#ff0000">
RESULT: ALIVE Identity has been verified.<BR>
COMMENT: unable to connect to host MYHOST.OCC.UC.EDU on port 7891<BR>
REQUIRE: HOST_PORT<BR>
WAITING:<BR>
</FONT>
<FONT color="green">
HOST_PORT myhost.occ.uc.edu 9971<BR>
</FONT>
</CODE>
<FONT color="#000000">
<P>
At this point, the  <FONT color="#ff0000">Monitor</FONT> will have to carry
out an Are-You-Alive transaction on the new host and port.
<P>
<BR>
<CODE>
<FONT color="#ff0000">
RESULT: HOST_PORT MYHOST.OCC.UC.EDU 9971<BR>
WAITING: <BR>
</FONT>
</CODE>
<P>
<b><font color="#0000BB" size=+1>Trade Transaction</font></b>
<p>
This transaction is used to perform trades with other players.  It would
normally start with an Operational Transaction, so that <FONT
color="green">Player A</FONT> can have an active client connection where she
can issue commands.
<BR>
<CODE>
<FONT color="#ff0000">
[...]
WAITING:<BR>
</FONT>
<FONT color="green">
TRADE_REQUEST Player_A steel 1 for Player_B glass 10<BR>
</FONT>
<FONT color="#ff0000">
RESULT: TRADE_REQUEST ACCEPTED<BR>
WAITING:<BR>
</FONT>
</CODE>
<FONT color="#000000">

This commands issues a request from the Player with identity
<CODE>Player_A</CODE> to trade one unit of steel for ten units of glass from
the Player with identity, <CODE>Player_B</CODE>.  In this case,
<CODE>Player_B</CODE> has accepted the trade.
<P>
Immediately after the valid <CODE>TRADE_REQUEST</CODE> was made by
<CODE>Player_A</CODE>, <FONT color="#ffa500">Player_B</FONT> will receive
the following on her server port.
</FONT>
<P>
<CODE>
<FONT color="#ff0000">
COMMENT: Game Monitor Version 2.2<BR>
REQUIRE: IDENT<BR>
WAITING: <BR>
</FONT>
<FONT color="#ffa500">
Ident Player_B<BR>
</FONT>
<FONT color="#ff0000">
PLAYER_PASSWORD_CHECKSUM:  36c00161466dc725834a9787fc0f18497361f0a6<BR>
RESULT: IDENT<BR>
TRADE: PLAYER_1 RUBBER 1 FOR PLAYER_2 STEEL 1 <BR>
REQUIRE: TRADE_RESPONSE<BR>
WAITING: <BR>
</FONT>
<FONT color="#ffa500">
TRADE_RESPONSE ACCEPT<BR>
</FONT>
</CODE>
<FONT color="#000000">
Since <CODE>Player_B</CODE> has accepted the trade, the <CODE>RESULT:</CODE>
back on <CODE>Player_A</CODE>'s connection reflects that.
</FONT>
<P>

<HR width="80%">
<p>
<font size=+1 color="#0000BB"><b>Synthesis:</b></font>
<p>
Players are permitted to synthesize the complex resources.  To perform the
synthesis, Players must have in the their holdings <STRONG>2 units</STRONG>
of each of the resources needed to build the complex resource.  The required
raw resources to build complex resources are listed in the table below:

<TABLE  bgcolor="#f0f0f0" border=1 cellpadding=5 cellspacing=5>
<TR align=center>
<TH width="25%">Complex Resource</TH>
<TH width="75%">Raw Resources Needed</TH>
<TR>
<TD width="25%">
<CODE>WEAPONS</CODE>
</TD>
<TD width="75%">
<CODE>STEEL, PLASTIC, OIL</CODE>
</TD>
</TR>
<TR>
<TD width="25%">
<CODE>COMPUTERS</CODE>
</TD>
<TD width="75%">
<CODE>COPPER, PLASTIC, GLASS</CODE>
</TD>
</TR>
<TD width="25%">
<CODE>VEHICLES</CODE>
</TD>
<TD width="75%">
<CODE>STEEL, RUBBER, GLASS, OIL</CODE>
</TD>
</TR>
</TABLE>

<HR width="80%">
<p>
<font size=+1 color="#0000BB"><b>Rules:</b></font>
<p>
In general, players are permitted to use whatever means that are not in
violation of state, federal, local law, and not in violation University of
Cincinnati, or College of Engineering rules, regulations, and computer usage
policies to win the game.
<P>
For example, impersonation of the Monitor is completely permitted.  In
addition, impersonation of another Player to the Monitor or other Players is
also permitted.
<P>
The following things are explicitly prohibited, and are considered poor game
conduct:
<UL>
<LI> Running a so-called Denial of Service attack on the Monitor server, any
    Player's server, or on any machine on the University of Cincinnati
    network or the Internet. (This includes sending multiple, rapid requests
    over and over to tie up a machine or server to stop it from getting any
    work done, or attempting to "crash" someone's machine or server.)
<LI> Refusing to answer requests on your server port based on what machine
     is connecting to you.  You should always answer all requests, and you
     may answer them with a "not interested" answer.  However, for game play
     to continue reasonably, you must respect and answer anyone connecting
     to your server port and sending you valid Message Groups.
</UL>
</td></tr>

<tr><td colspan=4><hr></td></tr>

<tr><td colspan=4>
<ADDRESS>
Copyright (&copy;) 1998 and 1999 by
<A HREF="http://www.ebb.org/bkuhn">Bradley M. Kuhn</A> and
<A HREF="http://www.ececs.uc.edu/~franco">John Franco</A>.<BR>
</ADDRESS>
<P>
Permission is granted to make and distribute verbatim copies of this
document materials provided the copyright notice and this permission notice
are preserved on all copies.
</P>
<P>
Permission is granted to copy and distribute modified versions of this
document under the conditions for verbatim copying, provided also that they
are marked clearly as modified versions, that the authors' names and title
are unchanged (though subtitles and additional authors' names may be added),
and that the entire resulting derived work is distributed under the terms of
a permission notice identical to this one.
</P>
</ADDRESS>
</td></tr>

</table>

</BODY>
</html>
<!--  LocalWords:  ececs helios ARGN ARG ARGI SHA IDENT hostname Ident Monitor's
 -->
<!--  LocalWords:  sender's NRMVEXUHFELPNN myhost occ fc MYLITTLESECRET B's txt
 -->
<!--  LocalWords:  ServerSocket proactive username IDENTS java se A's Karn
 -->
<!--  LocalWords:  DHKeyObject
 -->
